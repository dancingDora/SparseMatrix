# Lab0 : SparseMatrix
## 数据结构设计以及实现思路
### 类的设计
#### 节点类
ij表示位置，v表示值
```cpp
struct SPNode{
    int i, j;
    int v;
};

```
#### 稀疏矩阵类
mu，nu表示位置，tu表示非零元素个数，data表示非零界点集
```cpp
class SparseMatrix {
private:
    int mu, nu, tu;
    SPNode data[MAX_SIZE];
public:
    ...
};
```

### 特别的值：
* `rpot[] （B中每行第一个非零元素在data中位置）`
* `num[] （B中每行非零值数量）`
* `firstNZ 首个非零元素（暂存）`
* `temp[]（累加器）`
### 核心代码
* 获取`rpot[]`与`num[]`
```cpp
//calculate matrix B not zero enum number.
    for(int i = 1; i <= B.mu; i++) num[i] = 0; //初始化每行非零元素个数集num
    for(int i = 0; i < B.tu; i++) num[B.data[i].i]++; //计算B矩阵每行非零元素个数
    rpot[1] = 0;
    //calculate matrix B first not zero enum position.
    for(int i = 2; i <= B.mu; i++) rpot[i] = rpot[i - 1] + num[i - 1]; //计算B矩阵每行非零元素个数累加即第一个非零元素在data中位置
```


* 将`SparseMatrix B`中第k行的每一列非零元素与`*this`中非零元素记录到累加器中
```cpp
while(i == data[firstNZ].i) {
    k = data[firstNZ].j;//A : firstNZth not zero enum col
    if(k < B.mu) tmp = rpot[k + 1];
    else tmp = B.tu;
    for(int q = rpot[k]; q < tmp; q++) {
        int j = B.data[q].j;
        temp[j] += data[firstNZ].v * B.data[q].v;
    }
    firstNZ++;
}
```
* 赋值给C矩阵（结果）
```cpp
for(int j = 1; j <= B.nu; j++) {
    if(temp[j] != 0) {
        C->data[numNZ] = {i,j,temp[j]};
        numNZ++;
    }
}
```

* 思路就是运用了已给数据的有序性（先增加列后增加行）完成了稀疏矩阵的乘法

## 对比分析两种矩阵乘法

### 时间复杂度：
假设有两个矩阵 ： L_mn, R_nq

|    算法    | 时间复杂度  |                               分析                                |
|:--------:|:--------:|:---------------------------------------------------------------:|
|   矩阵乘法   | O(n^3) |                前提是左侧矩阵列数等于右侧矩阵行数，运算次数等于N * M * Q                |
|  稀疏矩阵乘法  | O(n^2) | N * Q （这个是求`temp[]`累加器的时间）,  L.enumNum * R.enumNum / N (求C的总时间) |

### 空间复杂度
假设有两个矩阵 ： L_mn, R_nq

|    算法    | 时间复杂度  |                          分析                           |
|:--------:|:------:|:-----------------------------------------------------:|
|   矩阵乘法   | O(n^2) |           R : m * n ; L : n * q 每个元素占据一个空间            |
|  稀疏矩阵乘法  |  O(n)  | 完全取决于矩阵内非零元素数量，最坏可能为nm，如果这样也不必用稀疏矩阵运算,计算次数约为`L.m * R.n` |

## 探究实验
### 矩阵存储所占内存空间分析

* 矩阵中1%（向下取整）为非零元素
    * 数据量过小（<10Kb）没有实际分析意义
    * 取1%的目的是如果想要知道其他数据如2%，5%可以直接乘法算出稀疏矩阵所需内存空间，了解大概占有内存空间

|  矩阵维度  | 100 * 100 | 500 * 500 | 1000 * 1000 | 10000 * 10000 |
|:------:|:---------:|:---------:|:-----------:|:-------------:|
| 稀疏矩阵空间 |   1.2Kb   |   30Kb    |    120Kb    |     12Mb      |
| 普通矩阵空间 |   40Kb    |    1Mb    |     4Mb     |     400Mb     |

* 矩阵中50%（向下取整）为非零元素
    * 选取50%目的为看出50%左右使用稀疏矩阵都是非常不划算的

|  矩阵维度  | 100 * 100 | 500 * 500 | 1000 * 1000 | 10000 * 10000 |
|:------:|:---------:|:---------:|:-----------:|:-------------:|
| 稀疏矩阵空间 |   60Kb    |   1.5Mb   |     6Mb     |     600Mb     |
| 普通矩阵空间 |   40Kb    |    1Mb    |     4Mb     |     400Mb     |

**推广可知,二者所占空间比例关系为:**
```
SparseMartrixSpace : MartrixSpace  =  (p(非零元素占全部元素的比例) * 3)  : 1
```
非零元素小于`1/3`时，使用稀疏矩阵算法对于空间来说更划算

### 矩阵乘法所需时间分析

* 矩阵中1%为非零元素，比较两方阵乘法运算循环次数

| 矩阵维度 | 100 * 100 | 500 * 500  | 1000 * 1000 | 10000 * 10000 |
|:----:|:---------:|:----------:|:-----------:|:-------------:|
| 稀疏矩阵 |    1e2    | 1.25 * 1e2 |     1e5     |      1e7      |
| 普通矩阵 |    1e6    | 2.5 * 1e7  |     1e9     |     1e12      |
